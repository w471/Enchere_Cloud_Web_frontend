import React, { createContext, forwardRef, useContext, useMemo, useRef, useState, useEffect, useId, useDeferredValue, useCallback } from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/*
 * References:
 * [ARIA1.1#comboBox]: https://www.w3.org/TR/wai-aria-1.1/#combobox
 * [ARIA1.2#comboBox]: https://www.w3.org/TR/wai-aria-1.2/#combobox
 *
 * Low-level Components:
 * - ComboboxInput: The textbox input field
 * - Listbox: The container that holds the list of options
 * - ListboxOption: One listbox option
 * - Highlight: Highlighting of matching text of the listbox option
 *
 * High-level Components:
 * - Combobox: A container that you can pass all low-level components yourself (advanced use-cases)
 * - DatalistInput: A container that renders all low-level components for you (simple use-cases)
 */
/*
 * "Typically, the default state of a combobox is collapsed." [ARIA1.1#combobox]
 * If the developer does not manage the open state on its own, by default this component will collapse the listbox.
 * This ensures that the datalist input components (by default) matches the behavior of the native datalist element
 */
var DEFAULT_IS_EXPANDED = false;
var IS_PRODUCTION = process.env.NODE_ENV === 'production';
/*
 * Utilities
 */
var contextRequiredWarning = function (name) {
    return "The ".concat(name, " component must be a child of Combobox. Please wrap the component inside Combobox to ensure that the required context is available.");
};
/**
 * This function is inspired by tiny-warning: https://github.com/alexreardon/tiny-warning
 */
function assertWithWarning(condition, text) {
    // wrapping in production check for better dead code elimination
    if (!IS_PRODUCTION) {
        if (condition) {
            return;
        }
        // check console for IE9 support which provides console
        if (typeof console !== 'undefined') {
            console.warn(text);
        }
        // Throwing an error and catching it immediately
        // to improve debugging
        // A consumer can use 'pause on caught exceptions'
        // https://github.com/facebook/react/issues/4216
        try {
            throw Error(text);
        }
        catch (x) { }
    }
}
var handleWith = function () {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (e) {
        return fns.forEach(function (fn) { return fn && fn(e); });
    };
};
var ComboboxContext = createContext({
    contextAvailable: true,
    listboxId: '',
    selectedItemId: '',
    isExpanded: DEFAULT_IS_EXPANDED,
    currentInputValue: '',
});
var useComboboxContext = function () { return useContext(ComboboxContext); };
/**
 * Use this hook to control the open state and input value of the combobox.
 * Pass the properties down to the DataListInput component.
 */
var useComboboxControls = function (params) {
    var _a = useStateRef(params === null || params === void 0 ? void 0 : params.isExpanded), isExpanded = _a[0], setIsExpanded = _a[1];
    var _b = useState((params === null || params === void 0 ? void 0 : params.initialValue) || ''), value = _b[0], setValue = _b[1];
    return {
        isExpanded: isExpanded,
        value: value,
        setIsExpanded: setIsExpanded,
        setValue: setValue,
    };
};
function useClassNameStr(className, params) {
    return useMemo(function () { return (!className || typeof className === 'string' ? className : className(params)); }, [params, className]);
}
/**
 * The helpers returned by this hook can be used
 * to construct a custom Combobox behavior to your liking.
 * Wrap the low-level components in the Combobox component
 * and pass the helpers down if you need them.
 */
function useComboboxHelpers(_a) {
    var itemsRef = _a.itemsRef, listboxRef = _a.listboxRef, comboboxInputRef = _a.comboboxInputRef, onSelect = _a.onSelect, isExpandedRef = _a.isExpandedRef, setIsExpanded = _a.setIsExpanded, setValue = _a.setValue, setSelectedItem = _a.setSelectedItem;
    /**
     * onChange callback for input field
     */
    var handleChange = useCallback(function (e) {
        if (setValue)
            setValue(e.currentTarget.value);
        if (setIsExpanded)
            setIsExpanded(true);
    }, [setValue, setIsExpanded]);
    /**
     * onFocus callback for input field
     */
    var expandOnFocus = useCallback(function () {
        if (!isExpandedRef.current && setIsExpanded)
            setIsExpanded(true);
    }, [setIsExpanded]);
    var handleCloseDatalist = useCallback(function () {
        if (isExpandedRef.current && setIsExpanded)
            setIsExpanded(false);
    }, [setIsExpanded]);
    /**
     * onKeyDown/onKeyUp callback for window
     */
    var closeOnEscape = useCallback(function (e) {
        if (e.key === 'Escape')
            handleCloseDatalist();
    }, []);
    /**
     * onClick callback for window
     */
    var handleClickOutside = useCallback(function (e) {
        if (!comboboxInputRef.current || !listboxRef.current)
            return;
        var targetElement = e.target;
        if (!targetElement ||
            (!listboxRef.current.contains(targetElement) && targetElement !== comboboxInputRef.current)) {
            handleCloseDatalist();
        }
    }, [handleCloseDatalist]);
    /**
     * onFocus callback for window
     */
    var handleFocusOutside = useCallback(function () {
        if (!comboboxInputRef.current || !listboxRef.current)
            return;
        var activeElement = document.activeElement;
        if (!activeElement || (!listboxRef.current.contains(activeElement) && activeElement !== comboboxInputRef.current)) {
            handleCloseDatalist();
        }
    }, [handleCloseDatalist]);
    /**
     * Callback for item selection (enter/click)
     */
    var handleSelect = useCallback(function (item) {
        // return focus to input field after selection
        if (comboboxInputRef.current)
            comboboxInputRef.current.focus();
        if (setValue)
            setValue(item.value);
        if (setIsExpanded)
            setIsExpanded(false);
        if (setSelectedItem)
            setSelectedItem(item);
        if (onSelect)
            onSelect(item); // onSelect at last to allow override of previous state changes
    }, [setValue, onSelect, setIsExpanded, setSelectedItem]);
    /**
     * keyDown callback for input field
     */
    var handleKeyDownOnInput = useCallback(function (e) {
        // Control+Option+Space is used by VoiceOver on Mac to open the menu
        var isControlOptionSpace = e.code === 'Space' && e.ctrlKey && e.altKey;
        var shouldVisitItems = e.key === 'ArrowDown' || isControlOptionSpace;
        if (!listboxRef.current || !shouldVisitItems)
            return;
        if (isControlOptionSpace)
            e.preventDefault();
        if (isExpandedRef.current) {
            var firstOption = listboxRef.current.firstElementChild;
            if (firstOption && typeof firstOption.focus === 'function')
                firstOption.focus();
        }
        else if (setIsExpanded) {
            setIsExpanded(true);
            // wait for next tick (render)
            window.setTimeout(function () {
                if (!listboxRef.current)
                    return;
                var firstOption = listboxRef.current.firstElementChild;
                if (firstOption && typeof firstOption.focus === 'function')
                    firstOption.focus();
            });
        }
    }, [setIsExpanded]);
    /**
     * keyDown callback for list element (listbox option)
     * Uses keyDown instead of keyUp to support "long-press" to quickly navigate through list
     */
    var handleKeyDownOnListboxOption = useCallback(function (e) {
        if (!itemsRef.current)
            return;
        var item = itemsRef.current.find(function (item) { return item.id === e.currentTarget.id; });
        if (!item)
            return;
        if (e.key === 'Enter')
            return handleSelect(item); // Enter should act as Click. This will also submit a one input form correctly with the latest value.
        if (!listboxRef.current || e.key === 'Escape' || e.key === 'Tab' || e.key === 'Shift')
            return; // Do nothing on meta keys
        // Used for navigation
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Alt') {
            e.preventDefault(); // prevent safari from doing crazy text selection things
            var nextNode = null;
            if (e.key === 'ArrowDown' || e.key === 'Alt') {
                nextNode = e.currentTarget.nextElementSibling || listboxRef.current.firstElementChild;
            }
            else {
                nextNode = e.currentTarget.previousElementSibling || listboxRef.current.lastElementChild;
            }
            if (!nextNode)
                return;
            var nextOption = nextNode;
            if (nextOption && typeof nextOption.focus === 'function')
                nextOption.focus();
            return;
        }
        // Anything else should go to the input field
        if (!comboboxInputRef.current)
            return;
        comboboxInputRef.current.focus();
        comboboxInputRef.current.dispatchEvent(new KeyboardEvent('keydown', { key: e.key }));
    }, [handleSelect]);
    return {
        closeOnEscape: closeOnEscape,
        handleClickOutside: handleClickOutside,
        handleFocusOutside: handleFocusOutside,
        handleChange: handleChange,
        expandOnFocus: expandOnFocus,
        handleSelect: handleSelect,
        handleKeyDownOnInput: handleKeyDownOnInput,
        handleKeyDownOnListboxOption: handleKeyDownOnListboxOption,
    };
}
/**
 * The textbox input field.
 * Does currently not implement aria-activedescendant which is not obligatory for datalist input components.
 * Autocomplete off to prevent browser autocomplete from interfering with our own; can be overridden with props.
 */
var ComboboxInput = forwardRef(function (_a, forwardedRef) {
    var value = _a.value, props = __rest(_a, ["value"]);
    var _b = useComboboxContext(), contextAvailable = _b.contextAvailable, listboxId = _b.listboxId, isExpanded = _b.isExpanded;
    assertWithWarning(contextAvailable, contextRequiredWarning(ComboboxInput.name));
    return (React.createElement("input", __assign({ autoComplete: "off" }, props, { ref: forwardedRef, value: value, type: "text", role: "combobox", "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-expanded": isExpanded, "aria-controls": listboxId })));
});
ComboboxInput.displayName = 'ComboboxInput';
/**
 * Optional highlight component for the listbox option text.
 * Should be wrapped by ListboxOption. Provide ListBoxOption an aria-label to ensure accessibility, especially if using mark.
 */
var Highlight = function (_a) {
    var children = _a.children, _b = _a.currentInput, currentInput = _b === void 0 ? '' : _b, _c = _a.as, as = _c === void 0 ? 'mark' : _c, props = __rest(_a, ["children", "currentInput", "as"]);
    var markedChildren = useMemo(function () {
        if (typeof children !== 'string') {
            return children;
        }
        var index = children.toLowerCase().indexOf(currentInput.toLowerCase());
        var inputLength = currentInput.length;
        if (index === -1 || !inputLength) {
            return children;
        }
        return (React.createElement(React.Fragment, null,
            children.substring(0, index),
            as === 'mark' ? (React.createElement("mark", __assign({}, props), children.substring(index, index + inputLength))) : (React.createElement("span", __assign({}, props), children.substring(index, inputLength))),
            children.substring(index + inputLength, children.length)));
    }, [currentInput, children]);
    return React.createElement(React.Fragment, null, markedChildren);
};
/**
 * One listbox option.
 */
var ListboxOption = forwardRef(function (_a, forwardedRef) {
    var children = _a.children, id = _a.id, className = _a.className, props = __rest(_a, ["children", "id", "className"]);
    var selectedItemId = useComboboxContext().selectedItemId;
    var classNameStr = useClassNameStr(className, {
        isSelected: !!id && id === selectedItemId,
    });
    return (React.createElement("li", __assign({}, props, { ref: forwardedRef, id: id, className: classNameStr, role: "option" }), children));
});
ListboxOption.displayName = 'ListboxOption';
/**
 * The combobox popup list.
 */
var Listbox = forwardRef(function (_a, forwardedRef) {
    var children = _a.children, props = __rest(_a, ["children"]);
    var _b = useComboboxContext(), contextAvailable = _b.contextAvailable, listboxId = _b.listboxId, isExpanded = _b.isExpanded;
    assertWithWarning(contextAvailable, contextRequiredWarning(Listbox.name));
    var isExpandedRef = useRef(isExpanded);
    var _c = useState(false), hasExpanded = _c[0], setHasExpanded = _c[1];
    useEffect(function () {
        if (!isExpanded) {
            setHasExpanded(false);
        }
        else if (isExpanded && isExpanded !== isExpandedRef.current) {
            setHasExpanded(true);
        }
        isExpandedRef.current = isExpanded; // drag pointer to the old value
    }, [isExpanded]);
    // TODO https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-live instead of title
    return (React.createElement("ul", __assign({}, props, { ref: forwardedRef, id: listboxId, role: "listbox", "aria-live": hasExpanded ? props['aria-live'] || 'polite' : 'off' }), children));
});
Listbox.displayName = 'Listbox';
/**
 * A container that you can pass all low-level components yourself for advanced use-cases.
 * The Combobox provides the context for the combobox low-level components.
 */
var Combobox = function (_a) {
    var currentInputValue = _a.currentInputValue, listboxId = _a.listboxId, selectedItemId = _a.selectedItemId, _b = _a.isExpanded, isExpanded = _b === void 0 ? true : _b, children = _a.children;
    var id = useId();
    return (React.createElement(ComboboxContext.Provider, { value: { currentInputValue: currentInputValue, contextAvailable: true, listboxId: listboxId || id, selectedItemId: selectedItemId, isExpanded: isExpanded } }, children));
};
Combobox.ComboboxInput = ComboboxInput;
Combobox.Listbox = Listbox;
Combobox.ListboxOption = ListboxOption;
Combobox.Highlight = Highlight;
/*
 * DatalistInput - high-level component & its utilities
 */
/**
 * Internal hook used to create a ref for a state value to allow access to the state value without triggering a re-render.
 */
function useStateRef(initialState) {
    var _a = useState(initialState), state = _a[0], setState = _a[1];
    var ref = useRef(initialState);
    var setStateRef = function (newState) {
        setState(newState);
        ref.current = newState;
    };
    return [state, setStateRef, ref];
}
/**
 * Internal hook used to manipulate the value of the input field.
 */
var useInternalValue = function (value, setValue) {
    var _a = useState(value || ''), internalValue = _a[0], setInternalValue = _a[1];
    var setValues = useCallback(function (newValue) {
        if (setValue) {
            setValue(newValue);
        }
        else {
            setInternalValue(newValue);
        }
    }, [setValue]);
    useEffect(function () {
        setInternalValue(value || '');
    }, [value]);
    return [internalValue, setValues];
};
/**
 * Internal hook to keep track of the selected item.
 */
function useInternalSelectedItem(item) {
    var _a = useState(item), selectedItem = _a[0], setSelectedItem = _a[1];
    useEffect(function () {
        setSelectedItem(item);
    }, [item]);
    return [selectedItem, setSelectedItem];
}
/**
 * Alternative function for matching the current input value (needle) and the values of the items array.
 * Returns true if item.value is not of type string (all items will be displayed and a custom filter must be used).
 */
var startsWithValueFilter = function (items, value) {
    if (value === void 0) { value = ''; }
    return items.filter(function (item) {
        return typeof item.value === 'string' ? item.value.substring(0, value.length).toLowerCase() === value.toLowerCase() : true;
    });
};
/**
 * Default function for matching the current input value (needle) and the values of the items array.
 * Returns true if item.value is not of type string (all items will be displayed and a custom filter must be used).
 */
var includesValueFilter = function (items, value) {
    if (value === void 0) { value = ''; }
    return items.filter(function (item) {
        return typeof item.value === 'string' ? item.value.toLowerCase().includes(value.toLocaleLowerCase()) : true;
    });
};
function useFilters(items, value, filters) {
    var filteredRef = useRef(items);
    var filtered = useMemo(function () { return filters.reduce(function (currentItems, filter) { return filter(currentItems, value); }, items); }, [items, filters, value]);
    useEffect(function () {
        filteredRef.current = filtered;
    }, [filtered]);
    return [filtered, filteredRef];
}
/**
 * DatalistInput implements all lower-level components for you and provides a simple API for controlling the combobox.
 * Note: Use the useComboboxControls hook to control the value and expanded state of the combobox.
 * DatalistInput implements the ARIA1.2#comboBox specification, including keyboard navigation with ArrowUp and ArrowDown.
 * DatalistInput does currently not implement aria-activedescendant but shifts the focus to the listbox options on ArrowUp and ArrowDown.
 * Note: tabIndex of all listbox options is set to -1 to allow the user to use tab or shift tab to jump out of the datalist without the need to tab through all options.
 */
var DatalistInput = forwardRef(function (_a, forwardedRef) {
    var label = _a.label, _b = _a.showLabel, showLabel = _b === void 0 ? true : _b, items = _a.items, selectedItem = _a.selectedItem, value = _a.value, setValue = _a.setValue, onSelect = _a.onSelect, placeholder = _a.placeholder, _c = _a.isExpanded, isExpanded = _c === void 0 ? DEFAULT_IS_EXPANDED : _c, setIsExpanded = _a.setIsExpanded, _d = _a.filters, filters = _d === void 0 ? [includesValueFilter] : _d, inputProps = _a.inputProps, labelProps = _a.labelProps, listboxOptionProps = _a.listboxOptionProps, listboxProps = _a.listboxProps, _e = _a.isExpandedClassName, isExpandedClassName = _e === void 0 ? '' : _e, _f = _a.isCollapsedClassName, isCollapsedClassName = _f === void 0 ? '' : _f, isExpandedStyle = _a.isExpandedStyle, isCollapsedStyle = _a.isCollapsedStyle, props = __rest(_a, ["label", "showLabel", "items", "selectedItem", "value", "setValue", "onSelect", "placeholder", "isExpanded", "setIsExpanded", "filters", "inputProps", "labelProps", "listboxOptionProps", "listboxProps", "isExpandedClassName", "isCollapsedClassName", "isExpandedStyle", "isCollapsedStyle"]);
    var _g = useStateRef(isExpanded), internalIsExpanded = _g[0], setInternalIsExpanded = _g[1], isExpandedRef = _g[2];
    var _h = useInternalValue(value, setValue), internalValue = _h[0], setInternalValue = _h[1];
    var internalTextboxId = useId();
    var debounceValue = useDeferredValue(internalValue);
    var _j = useFilters(items, debounceValue, filters), filteredItems = _j[0], filteredItemsRef = _j[1];
    var listboxRef = useRef(null);
    var comboboxInputRef = useRef(null);
    var _k = useInternalSelectedItem(selectedItem), internalSelectedItem = _k[0], setSelectedItem = _k[1];
    var setIsExpandedStates = useCallback(function (state) { return (setIsExpanded ? setIsExpanded(state) : setInternalIsExpanded(state)); }, [setIsExpanded]);
    var _l = useComboboxHelpers({
        listboxRef: listboxRef,
        comboboxInputRef: comboboxInputRef,
        isExpandedRef: isExpandedRef,
        setValue: setInternalValue,
        onSelect: onSelect,
        itemsRef: filteredItemsRef,
        setIsExpanded: setIsExpandedStates,
        setSelectedItem: setSelectedItem,
    }), handleClickOutside = _l.handleClickOutside, handleFocusOutside = _l.handleFocusOutside, closeOnEscape = _l.closeOnEscape, handleChange = _l.handleChange, expandOnFocus = _l.expandOnFocus, handleSelect = _l.handleSelect, handleKeyDownOnInput = _l.handleKeyDownOnInput, handleKeyDownOnListboxOption = _l.handleKeyDownOnListboxOption;
    useEffect(function () {
        setInternalIsExpanded(isExpanded);
    }, [isExpanded]);
    useEffect(function () {
        // separate useEffect so we don't re-run it twice with each dependency change
        window.addEventListener('click', handleClickOutside);
        window.addEventListener('keyup', closeOnEscape);
        return function () {
            window.removeEventListener('click', handleClickOutside);
            window.removeEventListener('keyup', closeOnEscape);
        };
    }, [handleClickOutside]);
    useEffect(function () {
        // separate useEffect so we don't re-run it twice with each dependency change
        window.addEventListener('focusin', handleFocusOutside);
        return function () {
            window.removeEventListener('focusin', handleFocusOutside);
        };
    }, [handleFocusOutside]);
    return (React.createElement("div", __assign({}, props, { ref: forwardedRef, className: "react-datalist-input__container ".concat(props.className) }),
        React.createElement(Combobox, { listboxId: listboxProps === null || listboxProps === void 0 ? void 0 : listboxProps.id, selectedItemId: internalSelectedItem === null || internalSelectedItem === void 0 ? void 0 : internalSelectedItem.id, isExpanded: internalIsExpanded, currentInputValue: internalValue },
            showLabel && (React.createElement("label", __assign({}, labelProps, { className: "react-datalist-input__label ".concat(labelProps === null || labelProps === void 0 ? void 0 : labelProps.className), htmlFor: (inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) || internalTextboxId }), label)),
            React.createElement(ComboboxInput, __assign({}, inputProps, { ref: comboboxInputRef, id: (inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) || internalTextboxId, placeholder: placeholder, value: internalValue, onClick: handleWith(expandOnFocus, inputProps === null || inputProps === void 0 ? void 0 : inputProps.onClick), onFocus: handleWith(expandOnFocus, inputProps === null || inputProps === void 0 ? void 0 : inputProps.onFocus), onChange: handleWith(handleChange, inputProps === null || inputProps === void 0 ? void 0 : inputProps.onChange), onKeyDown: handleWith(handleKeyDownOnInput, inputProps === null || inputProps === void 0 ? void 0 : inputProps.onKeyDown), "aria-label": !showLabel && typeof label === 'string' ? label : undefined, className: "react-datalist-input__textbox ".concat(inputProps === null || inputProps === void 0 ? void 0 : inputProps.className) })),
            ((filteredItems.length && internalIsExpanded) || isCollapsedClassName || isCollapsedStyle) && (React.createElement(Listbox, __assign({}, listboxProps, { ref: listboxRef, "aria-hidden": internalIsExpanded, className: "react-datalist-input__listbox ".concat(internalIsExpanded ? isExpandedClassName : isCollapsedClassName, " ").concat((listboxProps === null || listboxProps === void 0 ? void 0 : listboxProps.className) || ''), style: __assign(__assign({}, (internalIsExpanded ? isExpandedStyle : isCollapsedStyle)), listboxProps === null || listboxProps === void 0 ? void 0 : listboxProps.style) }), filteredItems.map(function (item) { return (React.createElement(ListboxOption, __assign({}, listboxOptionProps, { "aria-label": item.label || item.value, key: item.id, id: item.id, tabIndex: -1, onClick: handleWith(function () { return handleSelect(item); }, listboxOptionProps === null || listboxOptionProps === void 0 ? void 0 : listboxOptionProps.onClick), onKeyDown: handleWith(handleKeyDownOnListboxOption, listboxOptionProps === null || listboxOptionProps === void 0 ? void 0 : listboxOptionProps.onKeyDown), className: "react-datalist-input__listbox-option ".concat(listboxOptionProps === null || listboxOptionProps === void 0 ? void 0 : listboxOptionProps.className) }),
                React.createElement(Highlight, { currentInput: internalValue }, item.node || item.value))); }))))));
});
DatalistInput.displayName = 'DatalistInput';

export { Combobox, DatalistInput, DatalistInput as default, includesValueFilter, startsWithValueFilter, useComboboxContext, useComboboxControls, useComboboxHelpers, useFilters };
//# sourceMappingURL=index.es.js.map
